{"meta":{"title":"ShaneD711's Blog","subtitle":"","description":"","author":"ShaneD711","url":"https://shaned711.github.io","root":"/"},"pages":[],"posts":[{"title":"Nginx 前后端分离架构配置：静态托管、API 反向代理与 WebSocket集成","slug":"Nginx-前后端分离架构配置详解：静态托管、API-反向代理与-WebSocket集成","date":"2025-12-01T07:06:12.000Z","updated":"2025-12-01T07:36:59.271Z","comments":true,"path":"2025/12/01/Nginx-前后端分离架构配置详解：静态托管、API-反向代理与-WebSocket集成/","permalink":"https://shaned711.github.io/2025/12/01/Nginx-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%9D%99%E6%80%81%E6%89%98%E7%AE%A1%E3%80%81API-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E-WebSocket%E9%9B%86%E6%88%90/","excerpt":"","text":"本次部署采用经典的 反向代理（Reverse Proxy） 模式。 流量入口：Nginx 监听宿主机的 80 端口。 前端应用：Vue 构建后的静态资源（HTML&#x2F;CSS&#x2F;JS），托管于 Nginx 本地。 后端服务：Spring Boot 应用运行于 8081 端口，不再直接对外暴露。 通信链路： HTTP 请求：由 Nginx 进行路径重写后转发。 WebSocket 连接：由 Nginx 处理握手并建立全双工 TCP 隧道。 1. Nginx 完整配置代码这是我目前正在使用的配置。Nginx 监听 80 端口，后端 Tomcat 运行在 8081 端口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; map $http_upgrade $connection_upgrade&#123; default upgrade; &#x27;&#x27; close; &#125; upstream webservers&#123; server 127.0.0.1:8081 weight=90 ; #server 127.0.0.1:8088 weight=10 ; &#125; # 主服务器配置 server &#123; listen 80; server_name localhost; location / &#123; root html/sky; index index.html index.htm; &#125; # 错误页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /opt/homebrew/var/www; &#125; location /api/ &#123; proxy_pass http://webservers/admin/; &#125; location /user/ &#123; proxy_pass http://webservers/user/; &#125; # WebSocket location /ws/ &#123; proxy_pass http://webservers/ws/; proxy_http_version 1.1; proxy_read_timeout 3600s; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;$connection_upgrade&quot;; &#125; &#125;&#125; 2. 配置详解：各部分的作用第一部分：Server 核心路由块123456server &#123; listen 80; server_name localhost; # ... locations ...&#125; Nginx 监听 80 端口，拦截所有发往 localhost 的请求，并根据 URI 前缀 进行路由分发。 第二部分：静态资源托管 加载前端页面 (Location &#x2F;)1234location / &#123; root html/sky; index index.html index.htm;&#125; 触发条件：当你在浏览器输入 http://localhost 时 处理逻辑：Nginx 不会去问后端，而是直接去电脑硬盘的 html/sky 目录下，找到 index.html 文件发送给浏览器，然后浏览器显示出网页界面。 第三部分：定义后端地址 (Upstream)123upstream webservers&#123; server 127.0.0.1:8081 weight=90 ;&#125; 作用：给运行在 8081 端口的 Java 后端起个名字叫 webservers。 好处：以后如果后端换了端口或增加了服务器，只需要改这里，下面的配置不用动。 第四部分：API 反向代理 转发业务接口 (Location &#x2F;api&#x2F;)123location /api/ &#123; proxy_pass http://webservers/admin/; &#125; 触发条件：当前端代码发起登录或查询等请求时（如 http://localhost/api/employee/login）。 处理逻辑： Nginx 拦截到路径里包含 /api/。 proxy_pass 将请求转发给 webservers 组（即 8081 端口）。 注意路径替换：Nginx 会把 URL 中的 /api/ 替换为 /admin/，因为后端接口定义的路径是 /admin/... 示例： 客户端请求：http://localhost/api/employee/login Nginx 转发：http://127.0.0.1:8081/admin/employee/login 结果：Java 后端收到请求，处理业务，返回数据。 第五部分：用户端接口转发123location /user/ &#123; proxy_pass http://webservers/user/;&#125; 逻辑：同上，将 /user/ 开头的请求转发到后端的 /user/ 模块，实现了管理端与用户端流量的物理隔离与逻辑统一。 第六部分：转发 WebSocket (Location &#x2F;ws&#x2F;)123456location /ws/ &#123; proxy_pass http://webservers/ws/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;$connection_upgrade&quot;;&#125; 触发条件：前端发起 ws://localhost/ws/xxx 连接请求时。 处理逻辑： proxy_pass：将请求转发给后端的 WebSocket 地址。 proxy_set_header：这是最关键的。它会在请求头里加上 Upgrade: websocket。如果不加这两行，后端会以为这只是普通的 HTTP 请求从而拒绝建立长连接。 结果：浏览器与后端建立了一条全双工的通信通道，用于实时消息推送。 3. 完整交互流程总结在这个架构下，前端、Nginx、后端是这样配合的： 用户访问网页： 浏览器 -&gt; Nginx (80端口) -&gt; 读取硬盘文件 -&gt; 返回 HTML 页面。 (此时后端不参与) 用户点击操作（如登录）： 浏览器 -&gt; 发送 /api/ 请求 -&gt; Nginx (80端口) -&gt; 修改路径为 /admin/ -&gt; 转发给后端 (8081端口) -&gt; 返回结果。 来单提醒（WebSocket）： 浏览器 -&gt; 发送 /ws/ 连接 -&gt; Nginx (80端口) -&gt; 添加协议升级头 -&gt; 转发给后端 (8081端口) -&gt; 建立长连接。 之后后端有新消息，直接通过这个连接推送到浏览器。 通过这套配置，成功实现了前后端分离的部署，并且对外只暴露一个 80 端口，既规范又安全。","categories":[],"tags":[]},{"title":"BaseContext：如何在Service层“隔空取物”获取当前登录用户ID？","slug":"BaseContext：如何在-Service-层“隔空取物”获取当前登录用户-ID？","date":"2025-11-28T06:37:54.000Z","updated":"2025-11-28T06:59:43.034Z","comments":true,"path":"2025/11/28/BaseContext：如何在-Service-层“隔空取物”获取当前登录用户-ID？/","permalink":"https://shaned711.github.io/2025/11/28/BaseContext%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8-Service-%E5%B1%82%E2%80%9C%E9%9A%94%E7%A9%BA%E5%8F%96%E7%89%A9%E2%80%9D%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7-ID%EF%BC%9F/","excerpt":"","text":"在做Spring Boot 的 Web 项目时，在 Controller 或 Service 层经常会看到这样一行代码： 12// 在 Service 层直接获取当前登录用户的ID Long userId = BaseContext.getCurrentId(); 这就很神奇了： 没有传参：Controller 调用 Service 时，并没有把 userId 作为参数传进来 没有查库：这一行代码也没有去查询数据库 数据准确：它总是能精准地拿到当前发送请求的那个用户的 ID，张三发请求拿到张三，李四发请求拿到李四，互不干扰 它是怎么做到的？ 有两个核心概念：ThreadLocal 和 Tomcat 的“一请求一线程”模型。 1.容器：ThreadLocal (线程局部变量)BaseContext 只是一个包装类，它内部的核心是 JDK 提供的 ThreadLocal。 12345678910111213141516public class BaseContext &#123; // 核心：ThreadLocal 对象 public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void setCurrentId(Long id) &#123; threadLocal.set(id); // 存入 &#125; public static Long getCurrentId() &#123; return threadLocal.get(); // 取出 &#125; public static void removeCurrentId() &#123; threadLocal.remove(); // 清除 &#125;&#125; ThreadLocal 的作用： 当我们在 线程 A 中往 ThreadLocal 存入数据时，只有 线程 A 能取出来 线程 B 即使访问同一个变量，也完全摸不到 线程 A 的数据 这就是线程隔离（Thread Safety） 2.环境：Tomcat 的“一请求一线程”模型Spring Boot 内置的 Web 服务器通常是 Tomcat。Tomcat 处理请求的机制是：One Request, One Thread （一个 HTTP 请求，由一个独立的线程全程负责） 当一个用户发起请求（比如“添加购物车”）时： Tomcat 分配 线程 X 来处理这个请求 拦截器 (Interceptor) 是 线程 X 执行的 Controller 是 线程 X 执行的 Service 还是 线程 X 执行的 Mapper 依然是 线程 X 执行的 结论： 只要我们没有手动开启新线程（new Thread），整个后端业务流程就像一场接力赛，但是是同一个运动员（线程 X） 从头跑到尾 流程基于以上两个原理，我们可以还原 userId 是如何从请求头一步步流转到 Service 层的： 第一步：拦截器 (存入) 请求刚到达后端，拦截器（JwtTokenUserInterceptor）最先拦截 第二步：Controller 拦截器放行后，代码进入 Controller 第三步：Service (取出) 代码进入 Service 层 为什么要这么设计？使用 ThreadLocal (BaseContext) 的方案，实现了数据在同一线程内的“隐式传递”，让代码极其简洁优雅。 总结 BaseContext 利用 ThreadLocal 实现了线程内部的数据隔离存储。 Tomcat 保证了从拦截器到 Service 处于 同一个线程 中。 二者结合，让我们可以在 Service 层“隔空”获取 Controller 层（拦截器）解析的数据，极大简化了代码结构。","categories":[],"tags":[]},{"title":"解决idea错误提示:无法解析'表名'","slug":"解决idea错误提示-无法解析-表名","date":"2025-11-24T05:56:47.000Z","updated":"2025-11-24T06:28:43.493Z","comments":true,"path":"2025/11/24/解决idea错误提示-无法解析-表名/","permalink":"https://shaned711.github.io/2025/11/24/%E8%A7%A3%E5%86%B3idea%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA-%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90-%E8%A1%A8%E5%90%8D/","excerpt":"","text":"1. 问题现象Database 面板里已经成功连接了数据库，表都能看得到。 SQL 代码（MyBatis XML 或 @Select 注解）本身没有语法错误，在数据库里执行也能跑通。 但是IDEA 编辑器里，提示 Unable to resolve table &#39;xxx&#39;。 2. 快速解决方案这个问题的根源在于 IDEA 不知道当前的代码文件应该对应哪个数据库连接。我们需要手动设置 SQL Resolution Scope（SQL 解析作用域）。 3. 为什么会有这个问题？我明明设置了 SQL Dialect（方言），也连接了数据库，而且我只有一个数据库，IDEA 为什么不能自己匹配呢？ 3.1 三大概念的区别 SQL Dialect (方言)：相当于“语法书”。它告诉 IDEA 这段代码是 MySQL 语法还是 Oracle 语法，负责检查语法结构（如 SELECT 拼写对不对）。 Data Source (数据源)：相当于“字典”。这是真实的数据库连接，包含所有的表结构元数据。 Resolution Scope (作用域)：相当于“指针&#x2F;上下文”。它的作用是把“代码”和“字典”连起来。 飘红的原因就是： 你有了语法书，也有了字典，但 IDEA 不知道这段代码该查哪本字典。 3.2 为什么不能选 “All Data Sources”？即使只有一个数据库，选“所有数据源”依然会报错。 本质原因：缺失“默认上下文” (Default Context)。 我们在写 SQL 时通常只写短表名（如 SELECT * FROM user），而不是全限定名（如 SELECT * FROM my_db.public.user）。 当你选“具体数据库”时： 相当于进入了该数据库的 Session，拥有了默认的 Schema。IDEA 遇到 user 表，会自动去默认 Schema 下查找。(相当于相对路径：./user) 当你选“所有数据源”时： 相当于站在了服务器的“大厅”里。虽然只有一个库，但因为没有执行 USE database 这种切换上下文的操作，IDEA 面对 user 这个短名，不敢擅自猜测它是属于哪个库的。为了严谨和防止歧义，它选择报错。(相当于绝对路径缺失)","categories":[],"tags":[]},{"title":"Hexo+Typora+PicGo搭建博客配置记录","slug":"Typora-PicGo-自动上传-Hexo-静态博客配置记录","date":"2025-11-21T12:31:38.000Z","updated":"2025-11-21T13:33:11.458Z","comments":true,"path":"2025/11/21/Typora-PicGo-自动上传-Hexo-静态博客配置记录/","permalink":"https://shaned711.github.io/2025/11/21/Typora-PicGo-%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0-Hexo-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Mac电脑配置一套写博客的环境,流程: 1.搭建 Hexo 博客 2.配置 PicGo + Typora 实现自动化写作 准备工作：在做任何安装之前，先解决 Git 和终端的网络问题 开启 Clash，查看端口是7897 打开终端 (Terminal)，依次执行以下命令： 123456789# 1. 让 Git 强制走代理 (解决连不上 GitHub)git config --global http.proxy http://127.0.0.1:7897git config --global https.proxy http://127.0.0.1:7897# 2. 让 Git 使用 HTTP/1.1 (解决 HTTP2 framing layer 报错)git config --global http.version HTTP/1.1# 3. 让 curl 也走 HTTP/1.1 (解决 Homebrew 下载报错)echo &quot;--http1.1&quot; &gt;&gt; ~/.curlrc 基础环境安装 (Node.js &amp; Git)123456789# 1. 给当前终端挂上全局代理 (加速下载)export https_proxy=http://127.0.0.1:7897 http_proxy=http://127.0.0.1:7897 all_proxy=http://127.0.0.1:7897# 2. 强制跳过更新，直接安装 Node.jsHOMEBREW_NO_AUTO_UPDATE=1 brew install node# 3. 验证安装node -vnpm -v 搭建 Hexo 博客主体把博客放在 ~/Documents/my-blog 12345678910111213# 1. 安装 Hexo 命令行工具npm install -g hexo-cli# 2. 初始化博客目录cd ~/Documentshexo init my-blog# 3. 进入目录并安装依赖cd my-blognpm install# 4. 安装 Git 推送插件npm install hexo-deployer-git --save 连接 GitHub 仓库在 GitHub 新建仓库 A： 仓库名：用户名.github.io (例如 ShaneD711.github.io) 权限：Public 修改 Hexo 配置： 用 IDEA 打开 my-blog 目录。 打开 _config.yml，拉到最底部，修改 deploy 部分： 1234deploy: type: git repo: https://github.com/你的用户名/你的用户名.github.io.git branch: main 回到终端，执行 1hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 成功后，访问 https://你的用户名.github.io 能看到网页 配置 PicGo 图床准备 GitHub 图片仓库 在 GitHub 新建仓库 B： 仓库名：blog-imgs 权限：Public 勾选 “Add a README file”。 获取 Token： GitHub -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens (classic)。 Generate new token -&gt; 勾选 repo -&gt; 生成并复制 Token。 安装 PicGo 并修复损坏提示 安装： 1brew install --cask picgo 修复“应用已损坏” ： 1sudo xattr -rd com.apple.quarantine /Applications/PicGo.app Typora 接入 打开 Typora -&gt; 设置 -&gt; 图像。 插入图片时：选择“上传图片”。 上传服务：选择 PicGo.app。 点击 “验证图片上传选项” 看到绿色的 Successfully 即可 标准日常写作流程新建： 12cd ~/Documents/my-bloghexo new &quot;文章标题&quot; 写作： 用 Typora 打开 source/_posts/文章标题.md。 截图 -&gt; 粘贴 (自动上传) -&gt; 写字 -&gt; 保存。 预览 ： 1hexo server 发布： 1hexo cl &amp;&amp; hexo g &amp;&amp; hexo d","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2025-11-21T09:39:02.256Z","updated":"2025-11-21T09:39:02.256Z","comments":true,"path":"2025/11/21/hello-world/","permalink":"https://shaned711.github.io/2025/11/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}